package service;

import exception.LottoException;
import exception.LottoExceptionCode;
import model.*;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.LongStream;

import static constant.LottoConstant.LOTTO_STRING_DELIMITER;
import static constant.LottoConstant.LOTTO_TICKET_PRICE;

public class LottoService {
    public boolean canProceedGameWithMoney(Money money) {
        return money.compare(LOTTO_TICKET_PRICE) >= 0;
    }

    public void validateManualLottoInputNumber(Long manualLottoInputNumber, Money money) {
        if (manualLottoInputNumber < 0) {
            throw new LottoException(LottoExceptionCode.NEGATIVE_MANUAL_LOTTO_COUNT);
        }

        long canBuyLottoCount = money.dividedByResult(LOTTO_TICKET_PRICE);
        if (canBuyLottoCount < manualLottoInputNumber) {
            throw new LottoException(LottoExceptionCode.INVALID_MANUAL_LOTTO_COUNT);
        }
    }

    public LottoGroup purchaseManualLottoGroup(List<String> manualLottoGroupString, Money money) {
        List<Lotto> lottoList = manualLottoGroupString.stream()
                .map(this::generateLottoWithLottoString)
                .collect(Collectors.toList());
        money.purchase((long) LOTTO_TICKET_PRICE * lottoList.size());
        return new LottoGroup(lottoList);
    }

    public LottoGroup purchaseAutoGeneratedLottoGroup(Money money) {
        long autoGeneratedLottoGroupSize = money.dividedByResult(LOTTO_TICKET_PRICE);
        List<Lotto> lottoList = LongStream.range(0, autoGeneratedLottoGroupSize)
                .boxed()
                .map(i -> new Lotto())
                .collect(Collectors.toList());
        return new LottoGroup(lottoList);
    }

    public Lotto generateLottoWithLottoString(String lottoString) {
        String[] splittedLottoString = lottoString.split(LOTTO_STRING_DELIMITER);
        List<Integer> LottoIntegerList = Arrays.stream(splittedLottoString)
                .map(Integer::parseInt)
                .collect(Collectors.toList());
        return new Lotto(LottoIntegerList);
    }

    public void validateWinningLotto(Lotto winningLotto, LottoNumber bonusNumber) {
        if (winningLotto.contains(bonusNumber)) {
            throw new LottoException(LottoExceptionCode.WINNING_LOTTO_SET_DUPLICATE);
        }
    }

    public LottoPrizeMap calculateLottoResult(LottoGroup lottoGroup, Lotto winningLotto, LottoNumber bonusNumber) {
        List<LottoPrize> lottoPrizeList = lottoGroup.getLottoGroup()
                .stream()
                .map(lotto -> LottoPrize.valueOf(lotto.matchNumber(winningLotto), lotto.contains(bonusNumber)))
                .collect(Collectors.toList());

        return new LottoPrizeMap(lottoPrizeList);
    }

    public double getEarningRates(LottoPrizeMap lottoPrizeMap, Money totalMoney) {
        long totalPrize = lottoPrizeMap.getTotalPrize();
        return totalMoney.divideResult((double) totalPrize);
    }
}
